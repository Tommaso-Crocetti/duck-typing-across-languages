// This file contains some of the examples generated by the AI to show duck typing in JavaScript.


function printFunctionName(func) {
  return function (...args) {
    console.log(`\nRunning ${func.name}:`);
    return func.apply(this, args);
  };
}

function duckTypingExample() {

    function makeQuack(animal) {
        if (typeof animal.quack === "function") {
            console.log(animal.quack());
        } else {
            console.log("This is not a duck!");
        }
    }
    
    const duck = { quack: () => "Quack!" };
    const person = { quack: () => "Person imitates duck" };
    const dog = { bark: () => "Woof!" };
    
    makeQuack(duck);    // "Quack!"
    makeQuack(person);  // "Person imitates duck"
    makeQuack(dog);     // "This is not a duck!"  :contentReference[oaicite:1]{index=1}
    
}

function duckTypingIterable() {
    function processLines(reader) {
        for (const line of reader) {
            console.log(line);
        }
    }

    const arrayReader = {
    *[Symbol.iterator]() {
        yield "line1";
        yield "line2";
    }
    };

    processLines(arrayReader); // prints "line1", "line2"

}

function duckTypingIterables() {
    function firstItem(collection) {
        for (const item of collection) {
            return item;
        }
        return null;
        }

        console.log(firstItem([1, 2, 3]));        // 1
        console.log(firstItem("hello world"));    // "h"
        console.log(firstItem(new Set([4, 5])));  // 4
}


function duckTypingLogger() {
    function logMessage(logger, level, message) {
        if (typeof logger.log !== "function") {
            throw new Error("Logger must implement log()");
        }
        logger.log(level, message);
        }

    const consoleLogger = { log: (l, m) => console.log(`${l}: ${m}`) };
    const fileLogger = {
    log(level, message) {
        /* imagine writing to a file */
        console.log(`(file) ${level}: ${message}`);
    }
    };

    logMessage(consoleLogger, "INFO", "Started");
    logMessage(fileLogger, "WARN", "Low disk space");
}

function duckTypingDynamic() {
    const httpResponse = { status: 200, body: "OK" };
    // Later we need it to behave like a file reader:
    httpResponse.read = function() {
        return `Status: ${this.status}, Body: ${this.body}`;
    };

    function processReader(reader) {
    console.log(reader.read());
    }

    processReader(httpResponse); // Works — no formal type required

}


function duckTypingAdapt() {
    function legacyLogger(message) {
        console.log("Legacy:", message);
    }

    function newLoggerInterface(obj) {
    if (typeof obj.log !== "function" && typeof obj === "function") {
        return {
        log: (...args) => obj(...args) // adapt function → object
        };
    }
    return obj;
    }

    function doLogging(logger, msg) {
    logger.log(msg);
    }

    doLogging(newLoggerInterface(legacyLogger), "Hello");
    // You can also pass { log(msg) { … } } directly without adaptation
}

printFunctionName(duckTypingExample)();
printFunctionName(duckTypingIterable)();
printFunctionName(duckTypingIterables)();
printFunctionName(duckTypingLogger)();
printFunctionName(duckTypingDynamic)();
printFunctionName(duckTypingAdapt)();