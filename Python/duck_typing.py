# This file contains some of the examples generated by the AI to show duck typing in Python.


def print_fun_name(func):
    def wrapper():
        print (f"\nRunning {func.__name__}:")
        func()
    return wrapper


@print_fun_name
def duck_typing_example():
    class Duck:
        def fly(self): print("Duck flying")
        def swim(self): print("Duck swimming")

    class Airplane:
        def fly(self): print("Airplane flying")
        def swim(self): pass  # no swim for airplane

    class Fish:
        def swim(self): print("Fish swimming")

    def travel(obj):
        obj.fly()    # expects fly
        obj.swim()   # expects swim

    for obj in [Duck(), Airplane(), Fish()]:
        try:
            travel(obj)
        except AttributeError as e:
            print(f"Error: {e}")

@print_fun_name
def duck_typing_reader():
    def process_data(reader):
        data = reader.read()
        print(f"Read {len(data)} bytes")

    class StringReader:
        def __init__(self, text): self.text = text
        def read(self): return self.text

    with open("data.txt", "w+") as f:
        process_data(f)          # real file

    process_data(StringReader("hello world"))  # custom object

@print_fun_name
def duck_typing_FileLike():
    def read_all_lines(reader):
        return [line.strip() for line in reader]

    with open("data.csv", "w+") as f:
        lines1 = read_all_lines(f)      # real file

    class CustomReader:
        def __init__(self, data):
            self._data = data.split("\n")
        def __iter__(self):
            return iter(self._data)

    lines2 = read_all_lines(CustomReader("a\nb\nc"))
    print(lines1, lines2)

@print_fun_name
def duck_typing_iterator():
    class CountUpTo:
        def __init__(self, limit): self.limit = limit
        def __iter__(self): return self
        def __next__(self):
            if self.limit <= 0:
                raise StopIteration
            self.limit -= 1
            return self.limit

    print(list(CountUpTo(5)))  # [4,3,2,1,0]

@print_fun_name
def duck_typing_iterators():
    def first_item(collection):
        if len(collection) == 0:
            return None
        return collection[0]

    print(first_item([1,2,3]))         # list
    print(first_item("hello"))         # string
    # hallucination of the AI, the following line won't execute 
    # since sets are unordered collections.
    #print(first_item({1,2,3}))         # set (unordered, but still len/iterate)

@print_fun_name
def duck_typing_callable():
    def call_if_callable(obj):
        try:
            obj()
        except TypeError:
            print("Not callable")
        else:
            print("Called successfully!")

    call_if_callable(lambda: print("Hi"))
    call_if_callable(42)

@print_fun_name
def duck_typing_logger():
    # Define a generic Logger interface in behavior only
    def log_message(logger, level, msg):
        logger.log(level, msg)

    # Two implementations:
    class ConsoleLogger:
        def log(self, level, msg): print(f"{level}: {msg}")

    class FileLogger:
        def __init__(self, filename): self.file = open(filename, "a")
        def log(self, level, msg): self.file.write(f"{level}: {msg}\n")

    log_message(ConsoleLogger(), "INFO", "Started")
    log_message(FileLogger("app.log"), "WARN", "Low disk")


duck_typing_example()
duck_typing_reader()
duck_typing_FileLike()
duck_typing_iterator()
duck_typing_iterators()
duck_typing_callable()
duck_typing_logger()